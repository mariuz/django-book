=====================================
Chapter 4: The Django template system
=====================================

In the previous chapter, you may have noticed something peculiar in how we
returned the HTML in our example views. Namely, the HTML was hard-coded
directly in our Python code!

This arrangement leads to several problems. Obviously, any change to the design
of the page would require a change to the Python code. For one thing, the
design of a site tends to change far more frequently than the underlying Python
code, so it would be convenient if the frequency of HTML changes were separated
from changes to Python code. Second, writing backend Python code and
designing/coding HTML are two different disciplines, and most professional Web
development environments split these responsibilities across separate people
(or even separate departments). Designers and HTML'ers shouldn't have to
edit Python code to get their job done; they should deal with HTML. Similarly,
it's most efficient if programmers can work on Python code and designers can
work on templates at the same time, rather than one person waiting for the
other to finish editing a single file that contains both Python and HTML.

For these reasons, it's much more maintainable, manageable and clean to
separate the design of the page from the Python code itself. We can do this
with Django's **template system**.

Template-system basics
======================

A Django template is just a bunch of text with placeholders and capability of
basic logic through **tags**. Here's a simple example template::

    <p>Dear {{ person_name }},</p>

    <p>Thanks for ordering {{ product }} from {{ company }}. It's scheduled to
    ship on {{ ship_date|date:"F j, Y" }}.</p>

    {% if ordered_warranty %}
    <p>Your warranty information will be included in the packaging.</p>
    {% endif %}

    <p>Sincerely,<br />{{ company }}</p>

This template is merely HTML with some **variables** and **template tags**
thrown in. Let's step through it:

    * Any bit of text that's surrounded by double-curly braces -- e.g.,
      ``{{ person_name }}`` -- is a **variable**. This means "insert the
      value of the variable with the given name." (But how do we specify the
      values of the variables in the first place? We'll get to that in a
      moment.)

    * Any bit of text that's surrounded by curly braces and percent signs --
      e.g., ``{% if ordered_warranty %}`` -- is a **block tag**. The definition
      of a block tag is quite broad: a block tag just tells the template system
      to *do something*.

      This example template only contains one block tag, the
      ``{% if ordered_warranty %}`` tag, which we refer to as an **"if" tag**.
      An "if" tag, as you may expect, acts as a logical "if" statement. In this
      example, the tag checks whether the value of the ``ordered_warranty``
      variable evaluates to ``True``. If it does, the template system will
      display everything between the ``{% if ordered_warranty %}`` and
      ``{% endif %}``. If not, the template system won't display that. (The
      template system also supports ``{% else %}``, as you may expect, and
      other various logic statements. We'll get to those in a bit.)

      Each Django template has access to several built-in block tags, which
      you'll learn about later in this chapter. In addition, you can write your
      own tags.

    * Finally, the second paragraph of this template has an example of a
      **filter**. Filters are a way to alter the display of a variable. In this
      example -- ``{{ ship_date|date:"F j, Y" }}`` -- we're passing the
      ``ship_date`` variable to the ``date`` filter, giving the ``date`` filter
      an argument ``"F j, Y"``. The ``date`` filter formats dates in a given
      format, as specified by that argument. Filters are attached using a pipe
      character (``|``), as a reference to Unix pipes.

      Each Django template has access to several built-in filters, which you'll
      learn about later in this chapter. In addition, you can write your own
      filters.

So, how do we feed data to this template so that it can fill those variable
placeholders? We use something called a **context**. Let's dip into the Python
interactive interpreter and see how this works in code.  (At the
command prompt, within the ``mysite`` directory, type 
``python manage.py shell`` to start the interactive interpreter.) ::

    >>> from django.template import Template, Context
    >>> raw_template = """<p>Dear {{ person_name }},</p>
    ...
    ... <p>Thanks for ordering {{ product }} from {{ company }}. It's scheduled to
    ... ship on {{ ship_date|date:"F j, Y" }}.</p>
    ...
    ... {% if ordered_warranty %}
    ... <p>Your warranty information will be included in the packaging.</p>
    ... {% endif %}
    ...
    ... <p>Sincerely,<br />{{ company }}</p>"""
    >>> t = Template(raw_template)
    >>> import datetime    
    >>> c = Context({'person_name': 'John Smith',
    ...     'product': 'Super Lawn Mower',
    ...     'company': 'Outdoor Equipment',
    ...     'ship_date': datetime.date(2009, 4, 2),
    ...     'ordered_warranty': True})
    >>> t.render(c)
    "<p>Dear John Smith,</p>\n\n<p>Thanks for ordering Super Lawn Mower from Outdoor Equipment.
    It's scheduled to ship on April 2, 2009.</p>\n\n<p>Your warranty information will be included
    in the packaging.</p>\n\n\n<p>Sincerely,<br />Outdoor Equipment</p>"

Let's step through this one statement at a time::

    * First, we import the classes ``Template`` and ``Context``, which both
      live in the module ``django.template``.

    * Next, save the raw text of our template into the variable
      ``raw_template``. Note that we use a triple quote marks to designate the
      string, because it wraps over multiple lines. (Also note that the three
      dots at the start of each line are inserted by the Python interactive
      interpreter -- they're not part of our template. We include them here to
      be faithful to the actual output of the interpreter. If you're copying
      and pasting this example to follow along, don't copy those three dots.)

    * Next, we create a template object ``t`` by passing ``raw_template`` to
      the ``Template`` class constructor.

    * Then we import the ``datetime`` module from Python's standard library,
      because we'll need it in the next statement.

    * Next, we create a context object ``c``. The ``Context`` constructor takes
      a Python dictionary mapping variable names to values. Here, for example,
      we specify that the ``person_name`` is ``'John Smith'``, etc.

    * Finally, we call the ``render()`` method on our template object, passing
      it the context. This returns the rendered template -- that is, it
      replaces template variables with the actual values of the variables, and
      it executes any block tags.

      Note that the warranty paragraph was displayed because the
      ``ordered_warranty`` variable evaluated to ``True``. Also note the
      formatted date, ``April 2, 2009``, which is formatted according to the
      format string ``'F j, Y'``, passed in the template. (We'll explain all
      the possible format strings for the ``date`` filter later.)

So that's all there is to using the Django template system -- just write a
template, create a template object, create a context and call the
``render()`` method.

Once you have a template object, you can render multiple contexts through it.
For example::

    >>> from django.template import Template, Context
    >>> t = Template('Hello, {{ name }}')
    >>> print t.render(Context({'name': 'John'}))
    Hello, John
    >>> print t.render(Context({'name': 'Julie'}))
    Hello, Julie
    >>> print t.render(Context({'name': 'Pat'}))
    Hello, Pat

Using templates in views
========================

So, then, we've learned the very basics of using the template system. Let's
plug this into a view. Recall the ``current_datetime`` view from the previous
chapter. Here's what it looked like::

    from django.http import HttpResponse
    import datetime

    def current_datetime(request):
        now = datetime.datetime.now()
        html = "<html><body>It is now %s.</body></html>" % now
        return HttpResponse(html)

Let's change this view to use Django's template system. At first, you might
think to do something like this::

    from django.template import Template, Context
    from django.http import HttpResponse
    import datetime

    def current_datetime(request):
        now = datetime.datetime.now()
        t = Template("<html><body>It is now {{ current_date }}.</body></html>")
        html = t.render(Context({'current_date': now}))
        return HttpResponse(html)

Sure, that uses the template system, but it doesn't solve the problems we
pointed out in the introduction of this chapter. Namely, the template is still
embedded in the Python code. Let's fix that by putting the template in a
*separate file*, which this view will load.

    TODO: Review this -- added by JGD
    
    First, create a directory, somewhere on your
    filesystem, whose contents Django can access. (Django runs as the same user
    as your web server.)  It doesn't really matter where these templates live; one
    good place is ``mysite/templates`` directory.
    
    Now edit ``TEMPLATE_DIRS`` in your ``settings.py`` to tell Django where it
    can find templates, adding the full path to the template directory you just created.
    
    When you've done that, create a new file, ``now.html`` in your template
    directory, and place the HTML, 
    ``<html><body>It is now {{ current_date }}.</body></html>`` in it.
    
    Next, change ``views.py`` to use load and use this template file::


    from django.template import loader, Context
    from django.http import HttpResponse
    import datetime

    def current_datetime(request):
        now = datetime.datetime.now()
        t = loader.get_template('now.html')
        html = t.render(Context({'current_date': now}))
        return HttpResponse(html)


Template system philosophy
==========================













.. About 50% of this chapter is taken from Django's template.txt doc.

If a view describes *what* data is displayed on a given page, the template
describes *how* that data looks. This distinction is important since it will
easily let you change how your site looks without having to change how it
behaves. Most web development teams already have different people who develop
the code who design the templates; this division in Django strives to match
that natural division of labor.

Django's template language is designed to strike a balance between power and
ease. It's designed to feel comfortable to those used to working with HTML. If
you have any exposure to other text-based template languages, such as Smarty
(http://smarty.php.net) or CheetahTemplate (http://www.cheetahtemplate.org/),
you should feel right at home with Django's templates.

.. admonition:: Ick, I hate it!

    We have a deep love for Django's template language, but not everyone
    shares our passion.  Luckily, like most of Django, there's nothing
    that binds you to using Django's template engine instead of the one
    of your choice. You can simply write views that render content using
    your favorite engine instead.

Django's template language has particularly been designed to be
designer-friendly. We think most programmers -- us included -- have the design
sense of a color-blind three-year-old, so we prefer to leave the designing to
the professionals by giving them a template language they can understand.

Tying up loose ends
===================

Let's get started by wrapping up the index template we started in the last
chapter. You'll recall that the view we're dealing with looks like::

    from django import template
    from django.http import HttpResponse
    from django.shortcuts import render_to_response, get_object_or_404
    from mysite.crimes.models import Crime, CrimeType

    def index(request):
        latest_crime_list = Crime.objects.all().order_by('-pub_date')[:10]
        return render_to_response('crimes/index.html', {
            'latest_crime_list': latest_crime_list,
            'type_list': CrimeType.objects.all(),
        })

Right now, the template is set up to only display the list of latest crimes
and doesn't display the list of crime types. On top of that, the template we
have so far isn't valid HTML at all; just a small snippet. Here's our take on
fixing both those problems::

    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
    <html lang="en">
    <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <title>Crimes in my city</title>
    </head>
    <body>
      {% if latest_crime_list %}
        <h2>Latest crimes:</h2>
        <ul>
        {% for crime in latest_crime_list %}
          <li>{{ crime.type }} at {{ crime.location }}
                [{{ crime.when|date:"F j, P" }}]</li>
        {% endfor %}
        </ul>

        <h2>Crimes by type:</h2>
        <ul>
        {% for type in type_list %}
          <li><a href="types/{{ type.id }}/">{{ type }}</a></li>
        {% endfor %}
        </ul>

      {% else %}
        <p>No crimes are available.</p>
      {% endif %}
    </body>
    </html>

That's better. Now we've got a complete (if still minimal) HTML page
displaying all the data available on the page. Let's focus on this template
and explain all the bits and pieces that go into making it.

What's a template
=================

First, though, what do we mean when we call the above a **template**? Well, a
template is simply a text file. It can generate any text-based format (HTML,
XML, CSV, etc.).

To do anything useful, template contains **variables**, which get replaced
with values when the template is evaluated, and **tags**, which control the
logic of the template.

.. admonition:: Philosophy

    Why use a text-based template instead of an XML-based one (like Zope's
    TAL)? We wanted Django's template language to be usable for more than
    just XML/HTML templates. At World Online, we use it for e-mails,
    JavaScript and CSV. You can use the template language for any text-based
    format.

    Oh, and one more thing: Making humans edit XML is just sadistic!

Variables
=========

Variables look like this: ``{{ variable }}``. When the template engine
encounters a variable, it evaluates that variable and replaces it with the
result.

Use a dot (``.``) to access attributes of a variable.

.. admonition:: Behind the scenes

    Technically, when the template system encounters a dot, it tries the
    following lookups, in this order:

        * Dictionary lookup
        * Attribute lookup
        * Method call
        * List-index lookup

In the above example, ``{{ crime.location }}`` will be replaced with the
``location`` attribute of the ``crime`` object.

Where did that ``crime`` object come from? It came from the context you
created in the view and passed into the template. All variables are evaluated
against the context that view creates.

If you use a variable that doesn't exist, the template system will insert
the value of the ``TEMPLATE_STRING_IF_INVALID`` setting which is set to an
empty string by default.

See "Using the built-in reference", below, for help on finding what variables
are available in a given template.

Filters
=======

You can modify variables for display by using **filters**.

Filters look like this: ``{{ name|lower }}``. This displays the value of the
``{{ name }}`` variable after being filtered through the ``lower`` filter,
which converts text to lowercase. Use a pipe (``|``) to apply a filter.

Filters can be "chained." The output of one filter is applied to the next.
``{{ text|escape|linebreaks }}`` is a common idiom for escaping text contents,
then converting line breaks to ``<p>`` tags.

Some filters take arguments. A filter argument looks like this:
``{{ bio|truncatewords:"30" }}``. This will display the first 30 words of the
``bio`` variable. Filter arguments always are in double quotes.

So, in the example above, ``{{ crime.when|date:"F j, P" }}`` outputs the value
of the ``crime``'s ``when`` attribute, formatted with the ``date`` filter
which is given the format string ``F j, P``. This ``date`` filter is based on
PHP's ``date()`` function and is described fully along with all the other
standard Django filters in Chapter XXX.

Tags
====

Tags look like this: ``{% tag %}``. Tags are more complex than variables: Some
create text in the output, some control flow by performing loops or logic, and
some load external information into the template to be used by later
variables.

Some tags require beginning and ending tags (i.e. ``{% tag %} ... tag contents
... {% endtag %}``). In the example above, both ``{% if %}`` and ``{% for %}``
are tags, and both require ending tags.

The built-in tag reference in Chapter XXX describes these and all the other
built-in tags, and Chapter 9 explains how to create your own tags.

Template inheritance
====================

The most powerful -- and thus the most complex -- part of Django's template
engine is template inheritance. Template inheritance allows you to build a
base "skeleton" template that contains all the common elements of your site
and defines **blocks** that child templates can override.

Understanding inheritance begins with understanding the problem it solves. The
template we designed above looks just fine, but what happens when we go to
create a template for the ``crimes_by_type`` view? If we want again to make a
nice valid HTML template, we'd start out something like::

    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
    <html lang="en">
    <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <title>{{ crime_type }} crimes</title>
    </head>
    <body>

    ...

But wait a minute -- we've just duplicated a lot of HTML! Imagine if we had a
few stylesheets included on each page, maybe a navigation bar, perhaps some
JavaScript... We'd end up putting all sorts of redundant HTML into each and
every template.

Clearly, this won't do -- what if you want to change all your templates to
XHTML 2 when it comes out? OK, so you probably won't want to do that, but what
about changing the included stylesheets? Can you imagine going into hundreds
of templates and changing all of them?

Ugh.

Template inheritance solves this problem (and a few others). You'll start out
by defining what's called a **base template** -- a skeleton of your page that
other templates will later fill in. Here's what a base template derived from
our ongoing example might look like::

    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
    <html lang="en">
    <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <title>{% block title %}{% endblock %}</title>
    </head>
    <body>
      <div id="content">
        {% block content %}{% endblock %}
      </div>

      <div id="footer">
        {% block footer %}
          Copyright Me, Myself, and I -- All rights reserved.
        {% endblock %}
      </div>
    </body>
    </html>


This template, which we'll call ``base.html``, defines a simple HTML skeleton
document that we'll use for all the pages on the site. It's the job of
"child" templates to fill the empty blocks with content.

In this example, the ``{% block %}`` tag defines three blocks that child
templates can fill in. All the ``block`` tag does is to tell the template
engine that a child template may override those portions of the template.

Now that we've got this base template, we can modify our existing index
template to use it::

    {% extends "base.html" %}

    {% block title %}Crimes in my city{% endblock %}

    {% block content %}
      {% if latest_crime_list %}
        <h2>Latest crimes:</h2>
        <ul>
        {% for crime in latest_crime_list %}
          <li>{{ crime.type }} at {{ crime.location }}
                [{{ crime.when|date:"F j, P" }}]</li>
        {% endfor %}
        </ul>

        <h2>Crimes by type:</h2>
        <ul>
        {% for type in type_list %}
          <li><a href="types/{{ type.id }}/">{{ type }}</a></li>
        {% endfor %}
        </ul>

      {% else %}
        <p>No crimes are available.</p>
      {% endif %}
    {% endblock %}

The ``{% extends %}`` tag is the key here. It tells the template engine that
this template "extends" another template. When the template system evaluates
this template, first it locates the parent -- in this case, "base.html".

At that point, the template engine will notice the three ``{% block %}`` tags
in ``base.html`` and replace those blocks with the contents of the child
template. So the title we've defined here will be used, as will all the
template code to loop over and display the crime list and list of crime types.
The skeleton from the base template will be filled in with the content from
the child one.

Note that since the child template didn't define the ``footer`` block, the
value from the parent template is used instead. Content within a ``{% block
%}`` tag in a parent template is always used as a fallback.

You can use as many levels of inheritance as needed. One common way of using
inheritance is the following three-level approach:

    * Create a ``base.html`` template that holds the main look-and-feel of
      your site.

    * Create a ``base_SECTION.html`` template for each "section" of your site.
      For example, ``base_news.html``, ``base_sports.html``. These templates
      all extend ``base.html`` and include section-specific styles/design.

    * Create individual templates for each type of page, such as a news
      article or blog entry. These templates extend the appropriate section
      template.

This approach maximizes code reuse and makes it easy to add items to shared
content areas, such as section-wide navigation.

Here are some tips for working with inheritance:

    * If you use ``{% extends %}`` in a template, it must be the first
      template tag in that template. Template inheritance won't work,
      otherwise.

    * More ``{% block %}`` tags in your base templates are better. Remember,
      child templates don't have to define all parent blocks, so you can fill
      in reasonable defaults in a number of blocks, then only define the ones
      you need later. It's better to have more hooks than fewer hooks.

    * If you find yourself duplicating content in a number of templates, it
      probably means you should move that content to a ``{% block %}`` in a
      parent template.

    * If you need to get the content of the block from the parent template,
      the ``{{ block.super }}`` variable will do the trick. This is useful if
      you want to add to the contents of a parent block instead of completely
      overriding it.

Finally, note that you can't define multiple ``{% block %}`` tags with the
same name in the same template. This limitation exists because a block tag
works in "both" directions. That is, a block tag doesn't just provide a hole
to fill -- it also defines the content that fills the hole in the *parent*. If
there were two similarly-named ``{% block %}`` tags in a template, that
template's parent wouldn't know which one of the blocks' content to use.

Using the built-in reference
============================

Django's admin interface includes a complete reference of all template tags
and filters available for a given site. To see it, go to your admin interface
and click the "Documentation" link in the upper right of the page.

The reference is divided into 4 sections: tags, filters, models, and views.

The **tags** and **filters** sections describe all the built-in tags (in fact,
the tag and filter references below come directly from those pages) as well as
any custom tag or filter libraries available.

The **views** page is the most valuable. Each URL in your site has a separate
entry here, and clicking on a URL will show you:

    * The name of the view function that generates that view.

    * A short description of what the view does.

    * The **context**, or a list of variables available in the view's
      template.

    * The name of the template or templates that are used for that view.

Each view documentation page also has a bookmarklet that you can use to jump
from any page to the documentation page for that view.

Because Django-powered sites usually use database objects, the **models**
section of the documentation page describes each type of object in the system
along with all the fields available on that object.

Taken together, the documentation pages should tell you every tag, filter,
variable and object available to you in a given template.

Custom tag and filter libraries
===============================

Certain applications provide custom tag and filter libraries. To access them
in a template, use the ``{% load %}`` tag::

    {% load comments %}

    {% comment_form for blogs.entries entry.id with is_public yes %}

In the above, the ``load`` tag loads the ``comments`` tag library, which then
makes the ``comment_form`` tag available for use. Consult the documentation
area in your admin to find the list of custom libraries in your installation.

The ``{% load %}`` tag can take multiple library names, separated by spaces.
Example::

    {% load comments i18n %}

Chapter 9 explains how you can write your own custom template tag libraries.

Custom libraries and template inheritance
-----------------------------------------

When you load a custom tag or filter library, the tags/filters are only made
available to the current template -- not any parent or child templates along
the template-inheritance path.

For example, if a template ``foo.html`` has ``{% load comments %}``, a child
template (e.g., one that has ``{% extends "foo.html" %}``) will *not* have
access to the comments template tags and filters. The child template is
responsible for its own ``{% load comments %}``.

This is a feature for the sake of maintainability and sanity.

What's next?
============

At this point, you should understand enough about how templates work to create
the crimes-by-type template yourself and retrofit the ``base.html`` we created
onto the existing crime detail template. Consider that your "homework".

At this point we've also covered nearly all the basics, and you're probably
ready to go out and create the Next Big Thingâ„¢. There's still one thing
missing, though -- a way to let the site interact with readers. In the next
chapter we'll plug that gap by explaining how Django does form processing.

Care to join us?

=====================================
Chapter 4: The Django template system
=====================================

In the previous chapter, you may have noticed something peculiar in how we
returned the HTML in our example views. Namely, the HTML was hard-coded
directly in our Python code!

This arrangement leads to several problems:

    * Obviously, any change to the design of the page would require a change to
      the Python code. The design of a site tends to change far more frequently
      than the underlying Python code, so it would be convenient if the
      frequency of HTML changes were separated from changes to Python code.

    * Second, writing backend Python code and designing/coding HTML are two
      different disciplines, and most professional Web development environments
      split these responsibilities across separate people (or even separate
      departments). Designers and HTML/CSS coders shouldn't have to edit Python
      code to get their job done; they should deal with HTML.

      Similarly, it's most efficient if programmers can work on Python code and
      designers can work on templates at the same time, rather than one person
      waiting for the other to finish editing a single file that contains both
      Python and HTML.

For these reasons, it's much more maintainable, manageable and clean to
separate the design of the page from the Python code itself. We can do this
with Django's **template system**.

Template system basics
======================

A Django template is a string of text that is intended to separate the
presentation of a document from its data, which can be dynamic. A template
defines placeholders and various bits of basic logic -- **tags** -- that
regulate how the document should be displayed. Usually, templates are used for
outputting HTML, but Django templates are equally capable of generating any
text-based format.

Let's dive in with a simple example template. This example template describes
an HTML page that thanks a person for making an order from a company. Think of
it as a form letter::

    <p>Dear {{ person_name }},</p>

    <p>Thanks for ordering {{ product }} from {{ company }}. It's scheduled to
    ship on {{ ship_date|date:"F j, Y" }}.</p>

    {% if ordered_warranty %}
    <p>Your warranty information will be included in the packaging.</p>
    {% endif %}

    <p>Sincerely,<br />{{ company }}</p>

This template is basic HTML with some **variables** and **template tags**
thrown in. Let's step through it:

    * Any text surrounded by double-curly braces -- e.g., ``{{ person_name }}``
      -- is a **variable**. This means "insert the
      value of the variable with the given name." (How do we specify the
      values of the variables? We'll get to that in a moment.)

    * Any text that's surrounded by curly braces and percent signs -- e.g.,
      ``{% if ordered_warranty %}`` -- is a **block tag**. The definition
      of a block tag is quite broad: A block tag just tells the template system
      to *do something*.

      This example template only contains one block tag, the
      ``{% if ordered_warranty %}`` tag, which we refer to as an **"if" tag**.
      An "if" tag, as you may expect, acts as a logical "if" statement. In this
      particular case, the tag checks whether the value of the ``ordered_warranty``
      variable evaluates to ``True``. If it does, the template system will
      display everything between the ``{% if ordered_warranty %}`` and
      ``{% endif %}``. If not, the template system won't display that. (The
      template system also supports ``{% else %}``, as you may expect, and
      other various logic statements.)

      Each Django template has access to several built-in block tags. In
      addition, you can write your own tags.

    * Finally, the second paragraph of this template has an example of a
      **filter**. Filters are a way to alter the display of a variable. In this
      example -- ``{{ ship_date|date:"F j, Y" }}`` -- we're passing the
      ``ship_date`` variable to the ``date`` filter, giving the ``date`` filter
      an argument ``"F j, Y"``. The ``date`` filter formats dates in a given
      format, as specified by that argument. Filters are attached using a pipe
      character (``|``), as a reference to Unix pipes.

      Each Django template has access to several built-in filters. In addition,
      you can write your own filters.

Using the template system
=========================

To use the template system in Python code, just follow these two steps:

    * First, create a ``Template`` object, which you can do by providing either
      the raw template code or a path to a file on the filesystem that
      contains your raw template code.

    * Then, you call the ``render()`` method of the ``Template`` object with a
      given set of variables -- the context. This returns a fully rendered
      template, as a string, with all of the variables and block tags
      evaluated according to the context.

Compiling a string
------------------

The easiest way to create a ``Template`` object is by instantiating it
directly. The ``Template`` class lives in the ``django.template`` module, and
the constructor takes one argument, the raw template code. Let's dip into the
Python interactive interpreter to see how this works in code. (Type ``python``
at the command line to start the interactive interpreter.) Here's a basic
walkthrough::

    >>> from django.template import Template
    >>> t = Template("My name is {{ my_name }}.")
    >>> print t
    <django.template.Template object>

If you're following along interactively, you'll see something like this after
typing ``print t``::

    <django.template.Template object at 0xb7d5f24c>

That ``0xb7d5f24c`` will be different every time, and it doesn't really matter;
it's simply the memory address of the ``Template`` object.

.. admonition:: Interactive interpreter examples

    Throughout this book, we'll feature example Python interactive interpreter
    sessions. You can recognize these examples by spotting the triple
    greater-than signs (``>>>``), which designate the interpreter's prompt. If
    you're copying examples from this book, don't copy those greater-than signs.

    Multi-line statements in the interactive interpreter are padded with three
    dots (``...``). For example::

        >>> print """This is a
        ...    string that spans
        ...    three lines."""
        This is a
        string that spans
        three lines.
        >>> def my_function(value):
        ...     print value
        >>> my_function('hello')
        hello

    Those three dots at the start of the additional lines are inserted by the
    Python shell -- they're not part of our input. We include them here to be
    faithful to the actual output of the interpreter. If you copy our examples
    to follow along, don't copy those dots.

When you create a ``Template`` object, the template system compiles the raw
template code into an internal, optimized form, ready for rendering. But if
your template code includes any syntax errors, the call to ``Template()`` will
cause a ``TemplateSyntaxError`` exception::

    >>> from django.template import Template
    >>> t = Template('{% notatag %} ')
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
      ...
      django.template.TemplateSyntaxError: Invalid block tag: 'notatag'

The system raises a ``TemplateSyntaxError`` exception for any of the following
cases::

    * Invalid block tags
    * Invalid arguments to valid block tags
    * Invalid filters
    * Invalid arguments to valid filters
    * Invalid template syntax
    * Unclosed block tags (for block tags that require closing tags)

Rendering a context
-------------------

Once you have a ``Template`` object, you can pass it data by giving it a
**context**. A context is simply a set of variables and their associated
values. A template uses this to populate its variable tags and evaluate its
block tags.

A context is represented in Python by the ``Context`` class, which lives in the
``django.template`` module. Its constructor takes one (optional) argument: a
dictionary mapping variable names to variable values. Call the ``Template``
object's ``render()`` method with the context to "fill" the template. For
example::

    >>> from django.template import Context, Template
    >>> t = Template("My name is {{ name }}.")
    >>> c = Context({"name": "Stephane"})
    >>> t.render(c)
    'My name is Stephane.'

Variable names must begin with a letter (A-Z) and may contain digits,
underscores and dots. (Dots are a special-case we'll get to in a moment.)
Variable names are case sensitive.

Here's an example of template compilation and rending, using the sample
template from the beginning of this chapter::

    >>> from django.template import Template, Context
    >>> raw_template = """<p>Dear {{ person_name }},</p>
    ...
    ... <p>Thanks for ordering {{ product }} from {{ company }}. It's scheduled to
    ... ship on {{ ship_date|date:"F j, Y" }}.</p>
    ...
    ... {% if ordered_warranty %}
    ... <p>Your warranty information will be included in the packaging.</p>
    ... {% endif %}
    ...
    ... <p>Sincerely,<br />{{ company }}</p>"""
    >>> t = Template(raw_template)
    >>> import datetime
    >>> c = Context({'person_name': 'John Smith',
    ...     'product': 'Super Lawn Mower',
    ...     'company': 'Outdoor Equipment',
    ...     'ship_date': datetime.date(2009, 4, 2),
    ...     'ordered_warranty': True})
    >>> t.render(c)
    "<p>Dear John Smith,</p>\n\n<p>Thanks for ordering Super Lawn Mower from Outdoor Equipment.
    It's scheduled to ship on April 2, 2009.</p>\n\n<p>Your warranty information will be included
    in the packaging.</p>\n\n\n<p>Sincerely,<br />Outdoor Equipment</p>"

Let's step through this one statement at a time::

    * First, we import the classes ``Template`` and ``Context``, which both
      live in the module ``django.template``.

    * Next, save the raw text of our template into the variable
      ``raw_template``. Note that we use a triple quote marks to designate the
      string, because it wraps over multiple lines; strings designated with
      single quote marks cannot be wrapped over multiple lines.

    * Next, we create a template object ``t`` by passing ``raw_template`` to
      the ``Template`` class constructor.

    * Then we import the ``datetime`` module from Python's standard library,
      because we'll need it in the following statement.

    * Next, we create a context object ``c``. The ``Context`` constructor takes
      a Python dictionary mapping variable names to values. Here, for example,
      we specify that the ``person_name`` is ``'John Smith'``, ``product`` is
      ``'Super Lawn Mower'``, etc.

    * Finally, we call the ``render()`` method on our template object, passing
      it the context. This returns the rendered template -- that is, it
      replaces template variables with the actual values of the variables, and
      it executes any block tags.

      Note that the warranty paragraph was displayed because the
      ``ordered_warranty`` variable evaluated to ``True``. Also note the
      formatted date, ``April 2, 2009``, which is formatted according to the
      format string ``'F j, Y'``, passed in the template. (We'll explain format
      strings for the ``date`` filter shortly.)

      If you're a Python newbie, you may wonder why this output includes
      newline characters (``'\n'``) rather than displaying the line breaks.
      That's happening because of a subtlety in the Python interactive
      interpreter: The call to ``t.render(c)`` returns a string, and by default
      the interactive interpreter displays the *representation* of the string,
      rather than the printed value of the string. If you want to see the
      string with line breaks displayed as true line breaks rather than ``'\n'``
      characters, use the ``print`` statement: ``print t.render(c)``.

That's all there is to using the Django template system -- just write a
template, create a template object, create a context and call the
``render()`` method.

Multiple contexts, same template
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Once you have a template object, you can render multiple contexts through it.
For example::

    >>> from django.template import Template, Context
    >>> t = Template('Hello, {{ name }}')
    >>> print t.render(Context({'name': 'John'}))
    Hello, John
    >>> print t.render(Context({'name': 'Julie'}))
    Hello, Julie
    >>> print t.render(Context({'name': 'Pat'}))
    Hello, Pat

Whenever you're using the same template to render multiple contexts like this,
it's most efficient to create the ``Template`` object *once*, then call
``render()`` on it multiple times. For example::

    # Bad
    for name in ('John', 'Julie', 'Pat'):
        t = Template('Hello, {{ name }}')
        print t.render(Context{'name': name})

    # Good
    t = Template('Hello, {{ name }}')
    for name in ('John', 'Julie', 'Pat'):
        print t.render(Context{'name': name})

Even so, Django's template parsing is quite fast. Behind the scenes, most of
the parsing happens via a single call to a single, short, regular expression.
This is a stark contrast to XML-based templating engines, which incur the
overhead of an XML parser and tend to be orders of magnitude slower than
Django's template rendering engine.

Context variable lookup
-----------------------

In the examples so far, we've passed simple values in the template contexts --
mostly strings, plus a ``datetime.date`` example. However, the template system
elegantly handles more complex data structures, such as lists, dictionaries and
custom objects.

The key to traversing complex data structures in Django templates is the dot
(``.``) character. Use a dot to access dictionary keys, attributes, indices or
methods of an object.

This is best illustrated with a few examples. First, say you're passing a
Python dictionary to a template. To access the values of that dictionary by
dictionary key, use a dot::

    >>> from django.template import Template, Context
    >>> person = {'name': 'Sally', 'age': '43'}
    >>> t = Template('{{ person.name }} is {{ person.age }} years old.')
    >>> c = Context({'person': person})
    >>> t.render(c)
    'Sally is 43 years old.'

Similarly, dots also allow access of object attributes. For example, a Python
``datetime.date`` object has ``year``, ``month`` and ``day`` attributes, and
you can use a dot to access those attributes in a Django template::

    >>> from django.template import Template, Context
    >>> import datetime
    >>> d = datetime.date(1993, 5, 2)
    >>> d.year
    1993
    >>> d.month
    5
    >>> d.day
    2
    >>> t = Template('The month is {{ date.month }} and the year is {{ date.year }}.')
    >>> c = Context({'date': d})
    >>> t.render(c)
    'The month is 5 and the year is 1993.'

This example uses a custom class::

    >>> from django.template import Template, Context
    >>> class Person(object):
    ...     def __init__(self, first_name, last_name):
    ...         self.first_name, self.last_name = first_name, last_name
    >>> t = Template('Hello, {{ person.first_name }} {{ person.last_name }}.')
    >>> c = Context({'person': Person('John', 'Smith')})
    >>> t.render(c)
    'Hello, John Smith.'

Dots are also used to access list indices. For example::

    >>> from django.template import Template, Context
    >>> t = Template('Item 2 is {{ items.2 }}.')
    >>> c = Context({'items': ['apples', 'bananas', 'carrots']})
    >>> t.render(c)
    'Item 2 is carrots.'

Negative list indices are not allowed. For example, the template variable
``{{ items.-1 }}`` would cause a ``TemplateSyntaxError``.

Finally, dots are also used to call methods on objects. For example, each
Python string has the methods ``upper()`` and ``isdigit()``, and you can call
those in Django templates using the same dot syntax::

    >>> from django.template import Template, Context
    >>> t = Template('{{ var }} | {{ var.upper }} | {{ var.isdigit }}')
    >>> t.render(Context({'var': 'hello'}))
    'hello | HELLO | False'
    >>> t.render(Context({'var': '123'}))
    '123 | 123 | True'

Note that, in the method calls, you don't include parentheses. Also, it's not
possible to pass arguments to the methods; you can only call methods that have
no required arguments. (We'll explain this philosophy later in this chapter.)

The dot lookups can be summarized like this: When the template system
encounters a dot in a variable name, it tries the following lookups, in this
order::

    * Dictionary lookup. Example: ``foo["bar"]``
    * Attribute lookup. Example: ``foo.bar``
    * Method call. Example: ``foo.bar()``
    * List-index lookup. Example: ``foo[bar]``

The system uses the first lookup type that works. It's short-circuit logic.

Dot lookups can be nested multiple levels deep. For instance, the following
example uses ``{{ person.name.upper }}``, which translates into a dictionary
lookup (``person['name']``), then a method call (``upper()``)::

    >>> from django.template import Template, Context
    >>> person = {'name': 'Sally', 'age': '43'}
    >>> t = Template('{{ person.name.upper }} is {{ person.age }} years old.')
    >>> c = Context({'person': person})
    >>> t.render(c)
    'SALLY is 43 years old.'

A word about method calls
~~~~~~~~~~~~~~~~~~~~~~~~~

Method calls are slightly more complex than the other lookup types. Here are
some things to keep in mind:

    * If, during the method lookup, a method raises an exception, the exception
      will be propagated, unless the exception has an attribute
      ``silent_variable_failure`` whose value is ``True``. If the exception
      *does* have a ``silent_variable_failure`` attribute, the variable will
      render as an empty string. For example::

        >>> t = Template("My name is {{ person.first_name }}.")
        >>> class PersonClass3:
        ...     def first_name(self):
        ...         raise AssertionError, "foo"
        >>> p = PersonClass3()
        >>> t.render(Context({"person": p}))
        Traceback (most recent call last):
        ...
        AssertionError: foo

        >>> class SilentAssertionError(AssertionError):
        ...     silent_variable_failure = True
        >>> class PersonClass4:
        ...     def first_name(self):
        ...         raise SilentAssertionError
        >>> p = PersonClass4()
        >>> t.render(Context({"person": p}))
        "My name is ."

    * A method call will only work if the method has no required arguments.
      Otherwise, the system will move to the next lookup type (list-index
      lookup).

    * Obviously, some methods have side effects, and it'd be either foolish or
      a security hole to allow the template system to access them.

      Say, for instance, you have a ``BankAccount`` object that has a
      ``delete()`` method. The template system shouldn't be allowed to do
      something like this::

        I will now delete this valuable data. {{ account.delete }}

      To prevent this, set a function attribute ``alters_data`` on the method.
      The template system won't execute a method if the method has
      ``alters_data=True`` set. For example::

          def delete(self):
              # Delete the account
          delete.alters_data = True

How invalid variables are handled
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

By default, if a variable doesn't exist, the template system renders it as an
empty string, failing silently. For example::

    >>> from django.template import Template, Context
    >>> t = Template('Your name is {{ name }}.')
    >>> t.render(Context())
    'Your name is .'
    >>> t.render(Context({'var': 'hello'}))
    'Your name is .'
    >>> t.render(Context({'NAME': 'hello'}))
    'Your name is .'
    >>> t.render(Context({'Name': 'hello'}))
    'Your name is .'

The system fails silently rather than raising an exception because it's
intended to be resilient to human error. In the real world, it's unacceptable
for a Web site to become inaccessible due to a small template syntax error.

Note that it's possible to change Django's default behavior in this regard, by
tweaking a setting called ``TEMPLATE_STRING_IF_INVALID``. We haven't covered
Django settings yet, but we'll discuss ``TEMPLATE_STRING_IF_INVALID`` in
Chapter 10, "Extending the template engine."

Playing with Context objects
----------------------------

Most of the time, you'll instantiate ``Context`` objects by passing in a
fully-populated dictionary to ``Context()``. But you can add and delete items
from a ``Context`` object once it's been instantiated, too, using standard
Python dictionary syntax::

    >>> from django.template import Context
    >>> c = Context({"foo": "bar"})
    >>> c['foo']
    'bar'
    >>> del c['foo']
    >>> c['foo']
    ''
    >>> c['newvariable'] = 'hello'
    >>> c['newvariable']
    'hello'

A ``Context`` object is a stack. That is, you can ``push()`` and ``pop()`` it.
If you ``pop()`` too much, it'll raise ``django.template.ContextPopException``::

    >>> c = Context()
    >>> c['foo'] = 'first level'
    >>> c.push()
    >>> c['foo'] = 'second level'
    >>> c['foo']
    'second level'
    >>> c.pop()
    >>> c['foo']
    'first level'
    >>> c['foo'] = 'overwritten'
    >>> c['foo']
    'overwritten'
    >>> c.pop()
    Traceback (most recent call last):
    ...
    django.template.ContextPopException

Using a ``Context`` as a stack comes in handy in some custom template tags, as
you'll see in Chapter 10.

Using templates in views
========================

We've learned the basics of using the template system; now, let's integrate
this into a view. Recall the ``current_datetime`` view from the previous
chapter. Here's what it looked like::

    from django.http import HttpResponse
    import datetime

    def current_datetime(request):
        now = datetime.datetime.now()
        html = "<html><body>It is now %s.</body></html>" % now
        return HttpResponse(html)

Let's change this view to use Django's template system. At first, you might
think to do something like this::

    from django.template import Template, Context
    from django.http import HttpResponse
    import datetime

    def current_datetime(request):
        now = datetime.datetime.now()
        t = Template("<html><body>It is now {{ current_date }}.</body></html>")
        html = t.render(Context({'current_date': now}))
        return HttpResponse(html)

Sure, that uses the template system, but it doesn't solve the problems we
pointed out in the introduction of this chapter. Namely, the template is still
embedded in the Python code. Let's fix that by putting the template in a
*separate file*, which this view will load.

The simple, "dumb" way to do this would be to save your template somewhere on
your filesystem and use Python's built-in file-opening functionality to read
the contents of the template. Here's what that might look like, assuming the
template were saved as the file ``/home/djangouser/templates/mytemplate.html``::

    from django.template import Template, Context
    from django.http import HttpResponse
    import datetime

    def current_datetime(request):
        now = datetime.datetime.now()
        # Simple, "dumb" way of saving templates on the filesystem.
        # This doesn't account for missing files!
        fp = open('/home/djangouser/templates/mytemplate.html')
        t = Template(fp.read())
        fp.close()
        html = t.render(Context({'current_date': now}))
        return HttpResponse(html)

This approach, however, is inelegant for these reasons:

    * For one, it doesn't handle the case of a missing file. If the file
      ``mytemplate.html`` doesn't exist or isn't readable, the ``open()`` call
      would raise an ``IOError`` exception.

    * Second, it hard-codes your template location. If you were to use this
      technique for every view function, you'd be duplicating the template
      locations. Not to mention that's a lot of typing!

    * Third, it includes a lot of boring boilerplate code. The calls to
      ``open()``, ``fp.read()`` and ``fp.close()`` require a lot of typing and
      not much creativity.

To solve these issues, we'll use *template loading* and *template directories*.

Template loading
================

Django provides a convenient and powerful API for loading templates from disk,
with the goal of removing redundancy both in your template-loading calls and in
your templates themselves.

In order to use this template-loading API, first you'll need to tell the
framework where you store your templates. The place to do this is in your
**settings file**.

A Django settings file is the place to put configuration for your Django
instance (aka your Django project). It's a simple Python module with
module-level variables, one for each setting.

When you ran ``django-admin.py startproject mysite`` in Chapter 2, the script
created a default settings file for you, aptly named ``settings.py``. Have a
look at the file's contents. It contains variables that look like this (though
not necessarily in this order)::

    DEBUG = True
    TIME_ZONE = 'America/Chicago'
    USE_I18N = True
    ROOT_URLCONF = 'mysite.urls'

This is pretty self-explanatory; the settings and their respective values are
simple Python variables. And because the settings file is just a plain Python
module, you can do dynamic things such as checking the value of one variable
before setting another. (This also means that you should avoid Python syntax
errors in your settings file.)

We'll cover settings files in depth later in this book, but for now, have a
look at the ``TEMPLATE_DIRS`` setting. This setting tells Django's template
loading mechanism where to look for templates. By default, it's an empty tuple.
Pick a directory where you'd like to store your templates, and add it to
``TEMPLATE_DIRS``, like so::

    TEMPLATE_DIRS = (
        '/home/django/mysite/templates',
    )

A few things to note:

    * You can specify any directory you want, as long as the directory and
      templates within that directory are readable by the user account under
      which your Web server runs. If you can't think of an obvious place to
      put your templates, we recommend creating a ``templates`` directory
      within your Django project (i.e., within the ``mysite`` directory you
      created in Chapter 2, if you've been following along with our examples).

    * Don't forget the comma at the end of the template-directory string!
      Python requires commas within single-element tuples to disambiguate the
      tuple from a parenthetical statement. This is a common newbie gotcha.

      If you want to avoid this error, you can make ``TEMPLATE_DIRS`` a list
      instead of a tuple, because single-element lists don't require a trailing
      comma::

          TEMPLATE_DIRS = [
              '/home/django/mysite/templates'
          ]

      A tuple is slightly more efficient than a list, though, so we recommend
      using a tuple for your ``TEMPLATE_DIRS`` setting.

    * It's simplest to use absolute paths, i.e. directory paths that start at
      the root of the filesystem. If you want to be a bit more flexible and
      decoupled, though, you can take advantage of the fact that Django
      settings files are just Python code by constructing the contents of
      ``TEMPLATE_DIRS`` dynamically. For example::

          import os.path

          TEMPLATE_DIRS = (
              os.path.join(os.path.basename(__file__), 'templates'),
          )

      This example uses the "magic" Python variable ``__file__``, which is
      automatically set to the filename of the Python module in which the code
      lives.

    * If you're on Windows, include your drive letter and use Unix-style
      forward slashes rather than backslashes. For example::

          TEMPLATE_DIRS = (
              'C:/www/django/templates',
          )

With ``TEMPLATE_DIRS`` set, the next step is to change the view code to
use Django's template-loading functionality rather than hard-coding the
template paths. Returning to our ``current_datetime`` view, let's change it
like so::

    from django.template.loader import get_template
    from django.template import Context
    from django.http import HttpResponse
    import datetime

    def current_datetime(request):
        now = datetime.datetime.now()
        t = get_template('current_datetime.html')
        html = t.render(Context({'current_date': now}))
        return HttpResponse(html)

In this example, we're using the function ``django.template.loader.get_template()``
rather than loading the template from the filesystem manually. The
``get_template()`` function takes a template name as its argument, figures out
where the template lives on the filesystem, opens that file and returns a
compiled ``Template`` object.

If ``get_template()`` cannot find the template with the given name, it raises
a ``TemplateDoesNotExist`` exception. To see what that looks like, fire up the
Django development server again, as in Chapter 3, by running
``python manage.py runserver`` within your Django project's directory. Then,
point your browser at the page that activates the ``current_datetime`` view
(e.g., ``http://127.0.0.1:8000/now/``). Assuming your ``DEBUG`` setting is set
to ``True`` and you haven't yet created a ``current_datetime.html`` template,
you should see a Django error page highlighting the ``TemplateDoesNotExist``
error.

(We'll have a screenshot here.)

This error page is similar to the one we explained in Chapter 3, with one
additional piece of debugging information: a "Template-loader postmortem"
section. This section tells you which templates Django tried to load, along
with the reason each attempt failed (e.g., "File does not exist"). This
information is invaluable when you're trying to debug template-loading errors.

As you can probably tell by looking at the error messages, Django attempted to
look for a template by combining the directory in your ``TEMPLATE_DIRS``
setting with the template name you passed to ``get_template()``. So if your
``TEMPLATE_DIRS`` contained ``'/home/django/templates'``, it would look for
the file ``'/home/django/templates/current_datetime.html'``.

Moving along, create the ``current_datetime.html`` file within your template
directory, using the following template code::

    <html><body>It is now {{ current_date }}.</body></html>

Refresh the page in your Web browser, and you should see the fully rendered
page.

render_to_response()
--------------------

Because it's such a common idiom to load a template, fill a ``Context`` and
return an ``HttpResponse`` object with the result of the rendered template,
Django provides a shortcut that lets you do those things in one line of code.
This shortcut is a function called ``render_to_response()``, which lives in the
module ``django.shortcuts``. Most of the time, you'll be using
``render_to_response()`` rather than loading templates and creating ``Context``
and ``HttpResponse`` objects manually.

Here's the ongoing ``current_datetime`` example rewritten to use
``render_to_response()``::

    from django.shortcuts import render_to_response
    import datetime

    def current_datetime(request):
        now = datetime.datetime.now()
        return render_to_response('current_datetime.html', {'current_date': now})

What a difference! Let's step through the code changes::

    * We no longer have to import ``get_template``, ``Template``, ``Context``
      or ``HttpResponse``. Instead, we import
      ``django.shortcuts.render_to_response``. The ``import datetime`` remains.

    * Within the ``current_datetime`` function, we still calculate ``now``, but
      the template loading, context creation, template rendering and
      ``HttpResponse`` creation is all taken care of by the
      ``render_to_response()`` call. Because ``render_to_response()`` returns
      an ``HttpResponse`` object, we can simply ``return`` that value in the
      view.

The first argument to ``render_to_response()`` should be the name of the
template to use, relative to your template directory. The second argument, if
given, should be a dictionary to use in creating a ``Context`` for that
template. If you don't provide a second argument, ``render_to_response()`` will
use an empty dictionary.

The locals() trick
------------------

Consider our latest incarnation of ``current_datetime``::

    def current_datetime(request):
        now = datetime.datetime.now()
        return render_to_response('current_datetime.html', {'current_date': now})

Many times, as in this example, you'll find yourself calculating some values,
storing them in variables (e.g., ``now`` above) and sending those variables to
the template. Particularly lazy programmers would note that it's slightly
redundant to have to give names for temporary variables *and* give names for
the template variables. Not only is it redundant; it's extra typing.

So if you're one of those lazy programmers and you like keeping code
particularly concise, you can take advantage of a built-in Python function
called ``locals()``. ``locals()`` returns a dictionary of all variables defined
within the local scope, along with their values. Thus, the above view could be
rewritten like so::

    def current_datetime(request):
        current_date = datetime.datetime.now()
        return render_to_response('current_datetime.html', locals())

Here, instead of manually specifying the context dictionary as before, we
instead pass the value of ``locals()``, which will include all variables
defined at that point in the function's execution. As a consequence, we've
renamed the ``now`` variable to ``current_date``, because that's the variable
name that the template expects. In this example, ``locals()`` doesn't offer a
*huge* improvement, but this technique can save you some typing if you've got
several template variables to define -- or if you're lazy.

One thing to watch out for when using ``locals()`` is that it includes *every*
local variable, which may comprise more variables than you actually want your
template to have access to. In the above example, ``locals()`` will also
include ``request``. Whether this matters to you depends on your application.

A final thing to consider is that ``locals()`` incurs a small bit of overhead,
because when you call it, Python has to create the dictionary dynamically. If
you specify the context dictionary manually, you avoid this overhead.

Template system philosophy
==========================













Template inheritance
====================

The most powerful -- and thus the most complex -- part of Django's template
engine is template inheritance. Template inheritance allows you to build a
base "skeleton" template that contains all the common elements of your site
and defines **blocks** that child templates can override.

Understanding inheritance begins with understanding the problem it solves. The
template we designed above looks just fine, but what happens when we go to
create a template for the ``crimes_by_type`` view? If we want again to make a
nice valid HTML template, we'd start out something like::

    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
    <html lang="en">
    <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <title>{{ crime_type }} crimes</title>
    </head>
    <body>

    ...

But wait a minute -- we've just duplicated a lot of HTML! Imagine if we had a
few stylesheets included on each page, maybe a navigation bar, perhaps some
JavaScript... We'd end up putting all sorts of redundant HTML into each and
every template.

Clearly, this won't do -- what if you want to change all your templates to
XHTML 2 when it comes out? OK, so you probably won't want to do that, but what
about changing the included stylesheets? Can you imagine going into hundreds
of templates and changing all of them?

Ugh.

Template inheritance solves this problem (and a few others). You'll start out
by defining what's called a **base template** -- a skeleton of your page that
other templates will later fill in. Here's what a base template derived from
our ongoing example might look like::

    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
    <html lang="en">
    <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <title>{% block title %}{% endblock %}</title>
    </head>
    <body>
      <div id="content">
        {% block content %}{% endblock %}
      </div>

      <div id="footer">
        {% block footer %}
          Copyright Me, Myself, and I -- All rights reserved.
        {% endblock %}
      </div>
    </body>
    </html>


This template, which we'll call ``base.html``, defines a simple HTML skeleton
document that we'll use for all the pages on the site. It's the job of
"child" templates to fill the empty blocks with content.

In this example, the ``{% block %}`` tag defines three blocks that child
templates can fill in. All the ``block`` tag does is to tell the template
engine that a child template may override those portions of the template.

Now that we've got this base template, we can modify our existing index
template to use it::

    {% extends "base.html" %}

    {% block title %}Crimes in my city{% endblock %}

    {% block content %}
      {% if latest_crime_list %}
        <h2>Latest crimes:</h2>
        <ul>
        {% for crime in latest_crime_list %}
          <li>{{ crime.type }} at {{ crime.location }}
                [{{ crime.when|date:"F j, P" }}]</li>
        {% endfor %}
        </ul>

        <h2>Crimes by type:</h2>
        <ul>
        {% for type in type_list %}
          <li><a href="types/{{ type.id }}/">{{ type }}</a></li>
        {% endfor %}
        </ul>

      {% else %}
        <p>No crimes are available.</p>
      {% endif %}
    {% endblock %}

The ``{% extends %}`` tag is the key here. It tells the template engine that
this template "extends" another template. When the template system evaluates
this template, first it locates the parent -- in this case, "base.html".

At that point, the template engine will notice the three ``{% block %}`` tags
in ``base.html`` and replace those blocks with the contents of the child
template. So the title we've defined here will be used, as will all the
template code to loop over and display the crime list and list of crime types.
The skeleton from the base template will be filled in with the content from
the child one.

Note that since the child template didn't define the ``footer`` block, the
value from the parent template is used instead. Content within a ``{% block
%}`` tag in a parent template is always used as a fallback.

You can use as many levels of inheritance as needed. One common way of using
inheritance is the following three-level approach:

    * Create a ``base.html`` template that holds the main look-and-feel of
      your site.

    * Create a ``base_SECTION.html`` template for each "section" of your site.
      For example, ``base_news.html``, ``base_sports.html``. These templates
      all extend ``base.html`` and include section-specific styles/design.

    * Create individual templates for each type of page, such as a news
      article or blog entry. These templates extend the appropriate section
      template.

This approach maximizes code reuse and makes it easy to add items to shared
content areas, such as section-wide navigation.

Here are some tips for working with inheritance:

    * If you use ``{% extends %}`` in a template, it must be the first
      template tag in that template. Template inheritance won't work,
      otherwise.

    * More ``{% block %}`` tags in your base templates are better. Remember,
      child templates don't have to define all parent blocks, so you can fill
      in reasonable defaults in a number of blocks, then only define the ones
      you need later. It's better to have more hooks than fewer hooks.

    * If you find yourself duplicating content in a number of templates, it
      probably means you should move that content to a ``{% block %}`` in a
      parent template.

    * If you need to get the content of the block from the parent template,
      the ``{{ block.super }}`` variable will do the trick. This is useful if
      you want to add to the contents of a parent block instead of completely
      overriding it.

Finally, note that you can't define multiple ``{% block %}`` tags with the
same name in the same template. This limitation exists because a block tag
works in "both" directions. That is, a block tag doesn't just provide a hole
to fill -- it also defines the content that fills the hole in the *parent*. If
there were two similarly-named ``{% block %}`` tags in a template, that
template's parent wouldn't know which one of the blocks' content to use.

Using the built-in reference
============================

Django's admin interface includes a complete reference of all template tags
and filters available for a given site. To see it, go to your admin interface
and click the "Documentation" link in the upper right of the page.

The reference is divided into 4 sections: tags, filters, models, and views.

The **tags** and **filters** sections describe all the built-in tags (in fact,
the tag and filter references below come directly from those pages) as well as
any custom tag or filter libraries available.

The **views** page is the most valuable. Each URL in your site has a separate
entry here, and clicking on a URL will show you:

    * The name of the view function that generates that view.

    * A short description of what the view does.

    * The **context**, or a list of variables available in the view's
      template.

    * The name of the template or templates that are used for that view.

Each view documentation page also has a bookmarklet that you can use to jump
from any page to the documentation page for that view.

Because Django-powered sites usually use database objects, the **models**
section of the documentation page describes each type of object in the system
along with all the fields available on that object.

Taken together, the documentation pages should tell you every tag, filter,
variable and object available to you in a given template.

Custom tag and filter libraries
===============================

Certain applications provide custom tag and filter libraries. To access them
in a template, use the ``{% load %}`` tag::

    {% load comments %}

    {% comment_form for blogs.entries entry.id with is_public yes %}

In the above, the ``load`` tag loads the ``comments`` tag library, which then
makes the ``comment_form`` tag available for use. Consult the documentation
area in your admin to find the list of custom libraries in your installation.

The ``{% load %}`` tag can take multiple library names, separated by spaces.
Example::

    {% load comments i18n %}

Chapter 9 explains how you can write your own custom template tag libraries.

Custom libraries and template inheritance
-----------------------------------------

When you load a custom tag or filter library, the tags/filters are only made
available to the current template -- not any parent or child templates along
the template-inheritance path.

For example, if a template ``foo.html`` has ``{% load comments %}``, a child
template (e.g., one that has ``{% extends "foo.html" %}``) will *not* have
access to the comments template tags and filters. The child template is
responsible for its own ``{% load comments %}``.

This is a feature for the sake of maintainability and sanity.

What's next?
============

At this point, you should understand enough about how templates work to create
the crimes-by-type template yourself and retrofit the ``base.html`` we created
onto the existing crime detail template. Consider that your "homework".

At this point we've also covered nearly all the basics, and you're probably
ready to go out and create the Next Big Thingâ„¢. There's still one thing
missing, though -- a way to let the site interact with readers. In the next
chapter we'll plug that gap by explaining how Django does form processing.



Multiple template directories
=============================

Template inheritance
====================

Philosophy
==========

locals() trick
==============

Other template systems
======================

Template syntax errors in the debug view
========================================
